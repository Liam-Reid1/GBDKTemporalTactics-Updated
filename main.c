/*
Updated code for GBDK v4.4.0
*/

#include <gb/gb.h>
#include <stdio.h>
#include <stdbool.h>
#include <rand.h>


UINT8 data[40][17][3];
UINT8 data2[40][17][2];
// flag x, flag y, target x, target y, flag #, flag total, target #, target total
UINT8 objective[8] = { 0, 0, 0, 0, 0, 0, 0, 1 };

// Hex arrays used for sprites and maps
unsigned char LoopGrid[] =
{
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,
  0x81,0x81,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x81,0x81,
  0xFF,0xFF,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x81,0x81,
  0xFF,0xFF,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x81,0x81,
  0x81,0x81,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0xFF,0xFF,
  0x81,0x81,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0xFF,0xFF,
  0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x81,0x81,
  0x81,0x81,0x80,0x80,0x80,0x80,0x80,0x80,
  0x80,0x80,0x80,0x80,0x80,0x80,0x81,0x81,
  0x81,0x81,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,
  0x81,0x81,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,
  0x3C,0x3C,0x66,0x66,0x70,0x70,0x38,0x38,
  0x0E,0x0E,0x66,0x66,0x3C,0x3C,0x00,0x00,
  0x1E,0x1E,0x33,0x33,0x60,0x60,0x60,0x60,
  0x60,0x60,0x33,0x33,0x1E,0x1E,0x00,0x00,
  0x7E,0x7E,0x33,0x33,0x33,0x33,0x3E,0x3E,
  0x36,0x36,0x33,0x33,0x73,0x73,0x00,0x00,
  0x63,0x63,0x77,0x77,0x7F,0x7F,0x7F,0x7F,
  0x6B,0x6B,0x63,0x63,0x63,0x63,0x63,0x63,
  0x1C,0x1C,0x36,0x36,0x63,0x63,0x63,0x63,
  0x63,0x63,0x63,0x63,0x36,0x36,0x1C,0x1C,
  0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
  0x66,0x66,0x66,0x66,0x3C,0x3C,0x18,0x18
};

unsigned char LoopBKG1[] =
{
  0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
  0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
  0x66,0x69,0x67,0x67,0x6D,0x67,0x67,0x6D,0x67,0x67,
  0x6D,0x67,0x67,0x6D,0x67,0x67,0x6A,0x66,0x66,0x66,
  0x66,0x71,0x66,0x66,0x71,0x66,0x66,0x71,0x66,0x66,
  0x71,0x66,0x66,0x71,0x66,0x66,0x71,0x66,0x66,0x66,
  0x66,0x71,0x66,0x66,0x71,0x66,0x66,0x71,0x66,0x66,
  0x71,0x66,0x66,0x71,0x66,0x66,0x71,0x72,0x73,0x74,
  0x66,0x6E,0x67,0x67,0x68,0x67,0x67,0x68,0x67,0x67,
  0x68,0x67,0x67,0x68,0x67,0x67,0x70,0x66,0x66,0x66,
  0x66,0x71,0x66,0x66,0x71,0x66,0x66,0x71,0x66,0x66,
  0x71,0x66,0x66,0x71,0x66,0x66,0x71,0x66,0x66,0x66,
  0x66,0x71,0x66,0x66,0x71,0x66,0x66,0x71,0x66,0x66,
  0x71,0x66,0x66,0x71,0x66,0x66,0x71,0x66,0x66,0x66,
  0x66,0x6E,0x67,0x67,0x68,0x67,0x67,0x68,0x67,0x67,
  0x68,0x67,0x67,0x68,0x67,0x67,0x70,0x66,0x66,0x66,
  0x66,0x71,0x66,0x66,0x71,0x66,0x66,0x71,0x66,0x66,
  0x71,0x66,0x66,0x71,0x66,0x66,0x71,0x66,0x66,0x66,
  0x66,0x71,0x66,0x66,0x71,0x66,0x66,0x71,0x66,0x66,
  0x71,0x66,0x66,0x71,0x66,0x66,0x71,0x66,0x66,0x66,
  0x66,0x6E,0x67,0x67,0x68,0x67,0x67,0x68,0x67,0x67,
  0x68,0x67,0x67,0x68,0x67,0x67,0x70,0x66,0x66,0x66,
  0x66,0x71,0x66,0x66,0x71,0x66,0x66,0x71,0x66,0x66,
  0x71,0x66,0x66,0x71,0x66,0x66,0x71,0x75,0x76,0x77,
  0x66,0x71,0x66,0x66,0x71,0x66,0x66,0x71,0x66,0x66,
  0x71,0x66,0x66,0x71,0x66,0x66,0x71,0x66,0x66,0x66,
  0x66,0x6E,0x67,0x67,0x68,0x67,0x67,0x68,0x67,0x67,
  0x68,0x67,0x67,0x68,0x67,0x67,0x70,0x66,0x66,0x66,
  0x66,0x71,0x66,0x66,0x71,0x66,0x66,0x71,0x66,0x66,
  0x71,0x66,0x66,0x71,0x66,0x66,0x71,0x66,0x66,0x66,
  0x66,0x71,0x66,0x66,0x71,0x66,0x66,0x71,0x66,0x66,
  0x71,0x66,0x66,0x71,0x66,0x66,0x71,0x66,0x66,0x66,
  0x66,0x6C,0x67,0x67,0x6F,0x67,0x67,0x6F,0x67,0x67,
  0x6F,0x67,0x67,0x6F,0x67,0x67,0x6B,0x66,0x66,0x66,
  0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
  0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66
};

unsigned char LoopBKG2[] =
{
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x45,0x4C,
  0x45,0x43,0x54,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x69,
  0x6A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6C,
  0x6B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x54,0x41,
  0x52,0x54,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

unsigned char LoopBKG3[] =
{
  0x39,0x4F,0x55,0x00,0x42,0x4C,0x45,0x57,0x00,0x59,
  0x4F,0x55,0x52,0x53,0x45,0x4C,0x46,0x00,0x55,0x50,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x54,0x41,
  0x52,0x54,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

unsigned char LoopBKGGoal[] =
{
  0x00,0x00,0x00,0x33,0x54,0x41,0x47,0x45,0x00,0x23,
  0x4F,0x4D,0x50,0x4C,0x45,0x54,0x45,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x0B,0x11,0x00,0x27,
  0x4F,0x41,0x4C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

unsigned char LoopBKGTarget[] =
{
  0x00,0x00,0x00,0x33,0x54,0x41,0x47,0x45,0x00,0x23,
  0x4F,0x4D,0x50,0x4C,0x45,0x54,0x45,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x0B,0x11,0x00,0x34,
  0x41,0x52,0x47,0x45,0x54,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

unsigned char LoopBKGEnd[] =
{
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x52,
  0x55,0x48,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6B,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x54,
  0x41,0x52,0x54,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

unsigned char LoopShip[] =
{
  0x02,0x00,0x00,0x02,0x00,0x06,0x00,0x06,
  0x08,0x07,0x11,0x0E,0x02,0x1D,0x00,0x0B,
  0x40,0x00,0x00,0x40,0x00,0x60,0x00,0x60,
  0x10,0xE0,0x88,0x70,0x40,0xB8,0x00,0xD0,
  0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x40,
  0x10,0xE0,0x00,0x7C,0x41,0xBE,0x20,0xD0,
  0x20,0xD0,0x41,0xBE,0x00,0x7C,0x10,0xE0,
  0x20,0x40,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0xD0,0x40,0xB8,0x88,0x70,0x10,0xE0,
  0x00,0x60,0x00,0x60,0x00,0x40,0x40,0x00,
  0x00,0x0B,0x02,0x1D,0x11,0x0E,0x08,0x07,
  0x00,0x06,0x00,0x06,0x00,0x02,0x02,0x00,
  0x04,0x0B,0x82,0x7D,0x00,0x3E,0x08,0x07,
  0x04,0x02,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x02,
  0x08,0x07,0x00,0x3E,0x82,0x7D,0x04,0x0B,
  0x00,0x00,0x00,0x10,0x00,0x24,0x00,0x49,
  0x00,0x49,0x00,0x24,0x00,0x10,0x00,0x00,
  0x00,0x00,0x00,0x08,0x00,0x24,0x00,0x92,
  0x00,0x92,0x00,0x24,0x00,0x08,0x00,0x00,
  0x00,0x00,0x00,0x18,0x00,0x24,0x00,0x42,
  0x00,0x18,0x00,0x24,0x00,0x00,0x00,0x18,
  0x00,0x18,0x00,0x00,0x00,0x24,0x00,0x18,
  0x00,0x42,0x00,0x24,0x00,0x18,0x00,0x00
};

unsigned char LoopTarget[] =
{
  0x00,0x00,0x00,0x18,0x00,0x24,0x00,0x5A,
  0x00,0x5A,0x00,0x24,0x00,0x18,0x00,0x00,
  0x00,0x18,0x00,0x24,0x00,0x42,0x00,0x99,
  0x00,0x99,0x00,0x42,0x00,0x24,0x00,0x18
};

unsigned char LoopGoal[] =
{
  0x00,0x70,0x20,0x5C,0x38,0x47,0x20,0x5C,
  0x00,0x70,0x00,0x40,0x00,0x40,0x00,0x40,
  0x00,0x40,0x00,0x70,0x20,0x5C,0x38,0x47,
  0x20,0x5C,0x00,0x70,0x00,0x40,0x00,0x40
};

unsigned char LoopBullet[] =
{
  0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x24,
  0x18,0x24,0x00,0x18,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x18,0x00,0x24,0x18,
  0x24,0x18,0x18,0x00,0x00,0x00,0x00,0x00
};

unsigned char LoopScore[] =
{
  0x3E,0x3E,0x63,0x63,0x67,0x67,0x6F,0x6F,
  0x7B,0x7B,0x73,0x73,0x3E,0x3E,0x00,0x00,
  0x18,0x18,0x38,0x38,0x18,0x18,0x18,0x18,
  0x18,0x18,0x18,0x18,0x7E,0x7E,0x00,0x00,
  0x3C,0x3C,0x66,0x66,0x06,0x06,0x1C,0x1C,
  0x30,0x30,0x66,0x66,0x7E,0x7E,0x00,0x00,
  0x3C,0x3C,0x66,0x66,0x06,0x06,0x1C,0x1C,
  0x06,0x06,0x66,0x66,0x3C,0x3C,0x00,0x00,
  0x0E,0x0E,0x1E,0x1E,0x36,0x36,0x66,0x66,
  0x7F,0x7F,0x06,0x06,0x0F,0x0F,0x00,0x00,
  0x7E,0x7E,0x60,0x60,0x7C,0x7C,0x06,0x06,
  0x06,0x06,0x66,0x66,0x3C,0x3C,0x00,0x00,
  0x1C,0x1C,0x30,0x30,0x60,0x60,0x7C,0x7C,
  0x66,0x66,0x66,0x66,0x3C,0x3C,0x00,0x00,
  0x7E,0x7E,0x66,0x66,0x06,0x06,0x0C,0x0C,
  0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,
  0x3C,0x3C,0x66,0x66,0x66,0x66,0x3C,0x3C,
  0x66,0x66,0x66,0x66,0x3C,0x3C,0x00,0x00,
  0x3C,0x3C,0x66,0x66,0x66,0x66,0x3E,0x3E,
  0x06,0x06,0x0C,0x0C,0x38,0x38,0x00,0x00
};



INT8 directionX(UINT8 direction) { //directionX used mainly for sprite direction and moving
	switch (direction) {
	case 0: return(-4); break;
	case 1: return(0); break;
	case 2: return(4); break;
	case 3: return(0); break;
	default: return(-4);
	}
}
INT8 directionY(UINT8 direction) { //directionY used mainly for sprite direction and moving
	switch (direction) {
	case 0: return(0); break;
	case 1: return(-4); break;
	case 2: return(0); break;
	case 3: return(4); break;
	default: return(0);
	}
}
bool border(UINT8 x, UINT8 y) { // stops ship and bullet from escaping grid
	if (x >= 148 || x <= 4)
		return(false);
	else if (y >= 156 || y <= 12)
		return(false);
	return(true);
}
void diedAnimation2(UINT8 crash1, UINT8 crash2, UINT8 direction1, UINT8 direction2) { // collide with two ships
	switch (direction1) {
	case 0: set_sprite_tile(crash1 * 2, 8); set_sprite_tile(crash1 * 2 + 1, 9); break;
	case 1: set_sprite_tile(crash1 * 2, 10); set_sprite_tile(crash1 * 2 + 1, 11); break;
	case 2: set_sprite_tile(crash1 * 2, 9); set_sprite_tile(crash1 * 2 + 1, 8); break;
	case 3: set_sprite_tile(crash1 * 2, 11); set_sprite_tile(crash1 * 2 + 1, 10); break;
	}
	switch (direction2) {
	case 0: set_sprite_tile(crash2 * 2, 8); set_sprite_tile(crash2 * 2 + 1, 9); break;
	case 1: set_sprite_tile(crash2 * 2, 10); set_sprite_tile(crash2 * 2 + 1, 11); break;
	case 2: set_sprite_tile(crash2 * 2, 9); set_sprite_tile(crash2 * 2 + 1, 8); break;
	case 3: set_sprite_tile(crash2 * 2, 11); set_sprite_tile(crash2 * 2 + 1, 10); break;
	}
	delay(100);
	NR10_REG = 0x1E; // Hex values used for sound effects
	NR11_REG = 0x10;
	NR12_REG = 0xF3;
	NR13_REG = 0x00;
	NR14_REG = 0x87;
	for (int i = 0; i < 3; i++) {
		delay(100);
		for (int j = 0; j < 2; j++) {
			if (j == 0) {
				scroll_sprite(crash1 * 2, directionX(direction1) / 2, directionY(direction1) / 2);
				scroll_sprite(crash2 * 2, directionX(direction2) / 2, directionY(direction2) / 2);
			}
			else {
				scroll_sprite(crash1 * 2 + 1, -directionX(direction1) / 2, -directionY(direction1) / 2);
				scroll_sprite(crash2 * 2 + 1, -directionX(direction2) / 2, -directionY(direction2) / 2);
			}
		}
		delay(100);
	}
}

void diedAnimation(UINT8 crash, UINT8 direction) { // shoot a ship / run out of time
	switch (direction) {
	case 0: set_sprite_tile(crash * 2, 8); set_sprite_tile(crash * 2 + 1, 9); break;
	case 1: set_sprite_tile(crash * 2, 10); set_sprite_tile(crash * 2 + 1, 11); break;
	case 2: set_sprite_tile(crash * 2, 9); set_sprite_tile(crash * 2 + 1, 8); break;
	case 3: set_sprite_tile(crash * 2, 11); set_sprite_tile(crash * 2 + 1, 10); break;
	}
	delay(100);
	NR10_REG = 0x1E; 
	NR11_REG = 0x10;
	NR12_REG = 0xF3;
	NR13_REG = 0x00;
	NR14_REG = 0x87;
	for (int i = 0; i < 3; i++) {
		delay(100);
		for (int j = 0; j < 2; j++) {
			if (j == 0) {
				scroll_sprite(crash * 2, directionX(direction) / 2, directionY(direction) / 2);
			}
			else {
				scroll_sprite(crash * 2 + 1, -directionX(direction) / 2, -directionY(direction) / 2);
			}
		}
		delay(100);
	}
}
void targetAnimation(void) { // target breaking animation
	set_sprite_tile(33, 15);
	NR10_REG = 0X65;
	NR11_REG = 0XB1;
	NR12_REG = 0XA3;
	NR13_REG = 0X00;
	NR14_REG = 0X85;
	delay(100);
	move_sprite(33, 0, 0);
	set_sprite_tile(33, 14);
	delay(100);
}
bool crashCheck(UINT8 location[][3], UINT8 cloneCount) { // checks for collisions
	bool died = false;
	for (int i = 0; i < cloneCount; i++) {
		for (int j = i + 1; j <= cloneCount; j++) {
			if (location[i][0] != 0 && location[j][0] != 0) {
				if (location[i][0] == location[j][0] && location[i][1] == location[j][1]) {
					died = true;
					diedAnimation2(i, j, location[i][2], location[j][2]);
				}
			}
		}
	}
	return(died);
}
bool targetCheck(UINT8 objective[8], UINT8 shooter[3]) { // checks if target is in bullet path
	switch (shooter[2]) {
	case 0: 
		if (objective[2] == shooter[0] && objective[3] < shooter[1]) {
			objective[2] = 0; objective[3] = 0; targetAnimation(); return(true);
		}
		break;
	case 1:
		if (objective[3] == shooter[1] && objective[2] > shooter[0]) {
			objective[2] = 0; objective[3] = 0; targetAnimation(); return(true);
		}
		break;
	case 2:
		if (objective[2] == shooter[0] && objective[3] > shooter[1]) {
			objective[2] = 0; objective[3] = 0; targetAnimation(); return(true);
		}
		break;
	case 3:
		if (objective[3] == shooter[1] && objective[2] < shooter[0]) {
			objective[2] = 0; objective[3] = 0; targetAnimation(); return(true);
		}
		break;
	}
	return(false);
}
bool shootCheck(UINT8 location[][3], UINT8 cloneCount, UINT8 shooter[3]) { // checks if ship is in bullet path
	bool died = false;
	for (int i = 0; i <= cloneCount; i++) {
		switch (shooter[2]) {
		case 0:
			if (location[i][0] == shooter[0] && location[i][1] < shooter[1]) {
				diedAnimation(i, location[i][2]); died = true;
			}
			break;
		case 1: 
			if (location[i][1] == shooter[1] && location[i][0] > shooter[0]) {
				diedAnimation(i, location[i][2]); died = true;
			}
			break;
		case 2:
			if (location[i][0] == shooter[0] && location[i][1] > shooter[1]) {
				diedAnimation(i, location[i][2]); died = true;
			}
			break;
		case 3:
			if (location[i][1] == shooter[1] && location[i][0] < shooter[0]) {
				diedAnimation(i, location[i][2]); died = true;
			}
			break;
		}
	}
	return(died);
}
void bulletShoot(UINT8 x, UINT8 y, UINT8 direction) { // bullet animation and movement
	UINT8 sprite = 0;
	while (border(x, y)) {
		delay(20);
		scroll_sprite(34, -directionY(direction), directionX(direction));
		x -= directionY(direction);
		y += directionX(direction);
		switch (sprite) {
		case 0: sprite++; break;
		case 1: sprite--; break;
		}
		set_sprite_tile(34, 16 + sprite);
	}
}
void reverseShoot(UINT8 x, UINT8 y, UINT8 direction) { // reverse bullet movement
	UINT8 sprite = 0;
	UINT8 originX = x;
	UINT8 originY = y;
	switch (direction) {
	case 0: y = 12; break;
	case 1: x = 148; break;
	case 2: y = 156; break;
	case 3: x = 4; break;
	}
	move_sprite(34, x, y);
	while (originX != x || originY != y) {
		delay(20);
		scroll_sprite(34, directionY(direction), -directionX(direction));
		x -= -directionY(direction);
		y += -directionX(direction);
		switch (sprite) {
		case 0: sprite++; break;
		case 1: sprite--; break;
		}
		set_sprite_tile(34, 16 + sprite);
	}
}
void spriteUpdate(UINT8 time, UINT8 clone, UINT8 data[40][17][3], UINT8 data2[40][17][2], bool reverse) { // used for recap
	for (int i = 0; i <= clone * 2 + 2; i++) {
		if (i % 2 == 0) {
			set_sprite_tile(i, data[time][i / 2][2] * 2);
			move_sprite(i, data[time][i / 2][0] + directionX(data[time][i / 2][2]), data[time][i / 2][1] + directionY(data[time][i / 2][2]));
		}
		else {
			set_sprite_tile(i, data[time][i / 2][2] * 2 + 1);
			move_sprite(i, data[time][i / 2][0] - directionX(data[time][i / 2][2]), data[time][i / 2][1] - directionY(data[time][i / 2][2]));
		}
	}
	for (int i = 0; i <= clone * 2 + 2; i++) { // could be optimized but don't wanna
		if (data2[time][i / 2][0] == 1 && i % 2 == 1) {
			set_sprite_tile(34, 16);
			move_sprite(34, data[time][i / 2][0], data[time][i / 2][1]);
			if (reverse) {
				reverseShoot(data[time][i / 2][0], data[time][i / 2][1], data[time][i / 2][2]);
			}
			else {
				bulletShoot(data[time][i / 2][0], data[time][i / 2][1], data[time][i / 2][2]);
			}
			move_sprite(34, 0, 0);
		}
	}
}
void pointUpdate(UINT8 point, UINT8 type) { // score and move counter
	// 0 for score, 2 for move
	set_sprite_tile(36 + type, 18 + (point / 10));
	set_sprite_tile(37 + type, point % 10 + 18);
}
bool goalCheck(UINT8 location[3], UINT8 objective[8]) { // check if all objectives are complete
	if (location[0] == objective[0] && location[1] == objective[1] && objective[6] == 0) {
		NR10_REG = 0X65;
		NR11_REG = 0XB1;
		NR12_REG = 0XA3;
		NR13_REG = 0X00;
		NR14_REG = 0X85;
		return(true);
	}
	return(false);
}


void initArrays(void) {
    for (UINT8 i = 0; i < 40; i++) {
        for (UINT8 j = 0; j < 17; j++) {
            data2[i][j][0] = 0;
            data2[i][j][1] = 0;
            for (UINT8 k = 0; k < 4; k++) {
                data[i][j][k] = 0;
            }
        }
    }

    for (UINT8 i = 0; i < 8; i++) {
        objective[i] = 0;
    }

    // Set default positions if needed
    objective[0] = 76;  // Goal X
    objective[1] = 36;  // Goal Y
    objective[5] = 0;   // Flag number
    objective[7] = 1;   // Target total
}

void main(void) {
	initArrays();
	// these registers must be in this specific order!
	NR52_REG = 0x80; // is 1000 0000 in binary and turns on sound
	NR50_REG = 0x77; // sets the volume for both left and right channel just set to max 0x77
	NR51_REG = 0xFF; // is 1111 1111 in binary, select which chanels we want to use in this case all of them. One bit for the L one bit for the R of all four channels

	SPRITES_8x8;
	BGP_REG = DMG_PALETTE(DMG_BLACK, DMG_DARK_GRAY, DMG_LITE_GRAY, DMG_WHITE); // Palette for colour positions
	set_bkg_data(102, 18, LoopGrid); // Loads the background tile patterns into the VRAM
	set_bkg_tiles(0, 0, 20, 18, LoopBKG2); // Determines the placement of tiles for the background
	UINT8 textDelay = 0;
	UINT8 textPos = 0;
	while (joypad() == 0 && textPos != 21) { // I feel like there's a better way to do this
		if (textDelay == 0) {
			NR10_REG = 0X00;
			NR11_REG = 0X81;
			NR12_REG = 0X42;
			NR13_REG = 0X73;
			NR14_REG = 0X85;
			
			textDelay = 100;
			switch (textPos) { // Story + Controls
			case 0: printf("Press any button to skip.\n"); textDelay = 200; break;
			case 1: printf("Welcome to the\n"); break;
			case 2: printf("Loop Combat TrainingSimulator.\n"); break;
			case 3: printf("Your goal is to\nnavigate through thetraining field,\n"); textDelay = 125; break;
			case 4: printf("destroy any targets present,"); textDelay = 125; break;
			case 5: printf("and reach\nthe goal."); textDelay = 200; break;
			case 6: printf("Your ship\nis equipped with\n"); break;
			case 7: printf("Cardinal Boosters\n"); break;
			case 8: printf("(Use D - Pad to\nsteer, use A to moveforward),\n"); textDelay = 200; break;
			case 9: printf("Fractal Cannons\n"); break;
			case 10: printf("(Use B to shoot\ntargets),\n"); textDelay = 200; break;
			case 11: printf("and one Loop Charge per timeline."); break;
			case 12: printf("Upon\ncompleting all\nrequirements, "); break;
			case 13: printf("your\nscore will increase "); break;
			case 14: printf("and time will be\nreset.\n"); textDelay = 200; break;
			case 15: printf("WARNING!"); break;
			case 16: printf("DO NOT\nDESTROY YOUR PAST\nTIMELINES.\n"); textDelay = 200; break;
			case 17: printf("Doing so will resultin you violently\nbeing ripped from\ntime."); break;
			case 18: printf("Good luck,"); textDelay = 150; break;
			case 19: printf("\nbeginning\ntraining..."); textDelay = 200; break;
			}
			textPos++;
		}
		textDelay--;
		delay(10);
	}
	if (joypad() == 0) {
		delay(1000);
		printf("Made By\nLiam Reid\n(me)"); // wow so cool
		delay(200);
	}
	else {
		delay(1000);
	}

	OBP1_REG = DMG_PALETTE(DMG_BLACK, DMG_DARK_GRAY, DMG_LITE_GRAY, DMG_WHITE);
	OBP0_REG = DMG_PALETTE(DMG_WHITE, DMG_DARK_GRAY, DMG_LITE_GRAY, DMG_BLACK);
	set_sprite_data(0, 12, LoopShip); // Loads the data for all other sprites into the VRAM
	set_sprite_data(12, 2, LoopGoal);
	set_sprite_data(14, 2, LoopTarget);
	set_sprite_data(16, 2, LoopBullet);
	set_sprite_data(18, 10, LoopScore);

	// Player palette selector
	set_sprite_tile(0, 0);
	move_sprite(0, 80, 83);
	set_sprite_tile(1, 1);
	move_sprite(1, 88, 83);
	SHOW_SPRITES;
	UINT8 palette = 2; // I like palette 2 the most so it's default
	set_bkg_data(102, 18, LoopGrid);
	set_bkg_tiles(0, 0, 20, 18, LoopBKG2);
	while (joypad() != J_START) { // Start to continue
		if (joypad() & J_SELECT) { // Select to switch
			palette++;
			NR10_REG = 0X00;
			NR11_REG = 0X81;
			NR12_REG = 0X47;
			NR13_REG = 0X73;
			NR14_REG = 0X86;
			if (palette == 3) {
				palette = 0;
			}
			waitpadup();
		}
		switch (palette) {
		case 0: OBP0_REG = DMG_PALETTE(DMG_WHITE, DMG_DARK_GRAY, DMG_LITE_GRAY, DMG_BLACK); break;
		case 1: OBP0_REG = DMG_PALETTE(DMG_WHITE, DMG_LITE_GRAY, DMG_DARK_GRAY, DMG_BLACK); break;
		case 2: OBP0_REG = DMG_PALETTE(DMG_WHITE, DMG_BLACK, DMG_WHITE, DMG_BLACK); break;
		}
	}
	NR10_REG = 0X65;
	NR11_REG = 0XB1;
	NR12_REG = 0XA3;
	NR13_REG = 0X00;
	NR14_REG = 0X85;
	

	
	SHOW_SPRITES;
	SHOW_BKG;
	DISPLAY_ON;
	uint16_t seed = LY_REG;
	seed |= (uint16_t)DIV_REG << 8;
	initrand(seed);

	set_bkg_data(102, 18, LoopGrid);
	set_bkg_tiles(0, 0, 20, 18, LoopBKG2);
	delay(1000);
	for (UINT8 i = 0; i < 6; i++) {
		move_sprite(i, 0, 0);
	}
	// N E S W

	objective[0] = 76; objective[1] = 36; objective[4] = 0;
	/*
	for (UINT8 i = 0; i < 40; i++) {
		for (UINT8 j = 0; j < 17; j++) {
			data2[i][j][0] = 0; data2[i][j][1] = 0;
			for (UINT8 k = 0; k < 4; k++) {
				data[i][j][k] = 0;
			}
		}
	}
		*/
	data[0][0][0] = 76;
	data[0][0][1] = 132;

	set_sprite_tile(33, 14);
	set_sprite_tile(35, 12);
	set_sprite_tile(36, 18);
	set_sprite_tile(37, 18);
	set_sprite_tile(38, 22);
	set_sprite_tile(39, 18);
	move_sprite(35, 76, 36);
	move_sprite(36, 148, 50);
	move_sprite(37, 156, 50);
	move_sprite(38, 148, 115);
	move_sprite(39, 156, 115);
	// 1: time 2: sprite 3: x, y, direction
	UINT8 direction = 0; 
	UINT8 time = 0;
	UINT8 startTime = 1;
	UINT8 clone = 0;
	UINT8 delaySpeed = 0;
	UINT8 move = 40;
	UINT8 score = 0;
	bool died = true;
	SHOW_SPRITES;
	SHOW_BKG;
	DISPLAY_ON;
	set_bkg_data(102, 18, LoopGrid);
	set_bkg_tiles(0, 0, 20, 18, LoopBKG1);
	while (1) {
		direction = 0;
		time = 0;
		startTime = 1;
		clone = 0;
		delaySpeed = 0;
		move = 40;
		objective[0] = 76; objective[1] = 36; 
		if (died) {
			score = 0;
			objective[5] = 0; objective[7] = 1;
		}
		set_sprite_tile(33, 14);
		set_sprite_tile(35, 12);
		set_sprite_tile(36, 18);
		set_sprite_tile(37, 18);
		set_sprite_tile(38, 22);
		set_sprite_tile(39, 18);
		move_sprite(34, 0, 0);
		move_sprite(35, 76, 36);
		move_sprite(36, 148, 50);
		move_sprite(37, 156, 50);
		move_sprite(38, 148, 115);
		move_sprite(39, 156, 115);

		set_bkg_data(102, 18, LoopGrid);
		set_bkg_tiles(0, 0, 20, 18, LoopBKG1);
		if (objective[7] != 0) {
			do {
				objective[2] = (((UINT8)rand()) % (UINT8)5) * 24 + 28;
				objective[3] = (((UINT8)rand()) % (UINT8)5) * 24 + 36;
				set_sprite_tile(33, 14);
				move_sprite(33, objective[2], objective[3]);
			} while ((objective[2] == objective[0] && objective[3] == objective[1]));
		}
		if (score != 0 && score % 16 == 0) {
			score++;
		}
		for (UINT8 i = 0; i < 40; i++) {
			set_sprite_prop(i, 0);
			for (UINT8 j = 0; j < 17; j++) {
				data2[i][j][0] = 0; data2[i][j][1] = 0;
				for (UINT8 k = 0; k < 4; k++) {
					data[i][j][k] = 0;
				}
			}
		}
		set_sprite_prop(36, S_PALETTE);
		set_sprite_prop(37, S_PALETTE);
		set_sprite_prop(38, S_PALETTE);
		set_sprite_prop(39, S_PALETTE);
		data[0][0][0] = 76;
		data[0][0][1] = 132;
		spriteUpdate(time, clone, data, data2, false);
		pointUpdate(score, 0);
		pointUpdate(move, 2);
		direction = 0; time = 0; startTime = 1; clone = 0; delaySpeed = 0; move = 40; died = false;
		SHOW_BKG;
		DISPLAY_ON;
		set_bkg_data(102, 18, LoopGrid);
		set_bkg_tiles(0, 0, 20, 18, LoopBKG1);
		if (score != 0) {
			if (objective[5] == objective[7]) {
				objective[7]++;
				set_bkg_data(102, 18, LoopGrid);
				set_bkg_tiles(0, 0, 20, 18, LoopBKGTarget);
				NR10_REG = 0X00;
				NR11_REG = 0X81;
				NR12_REG = 0X42;
				NR13_REG = 0X73;
				NR14_REG = 0X85;
				delay(2000);
				set_bkg_data(102, 18, LoopGrid);
				set_bkg_tiles(0, 0, 20, 18, LoopBKG1);
				NR10_REG = 0X00;
				NR11_REG = 0X81;
				NR12_REG = 0X42;
				NR13_REG = 0X73;
				NR14_REG = 0X85;
				do {
					objective[2] = (((UINT8)rand()) % (UINT8)5) * 24 + 28;
					objective[3] = (((UINT8)rand()) % (UINT8)5) * 24 + 36;
					set_sprite_tile(33, 14);
					move_sprite(33, objective[2], objective[3]);
				} while ((objective[2] == objective[0] && objective[3] == objective[1]));
			}
			else {
				objective[5]++;
				set_bkg_data(102, 18, LoopGrid);
				set_bkg_tiles(0, 0, 20, 18, LoopBKGGoal);
				NR10_REG = 0X00;
				NR11_REG = 0X81;
				NR12_REG = 0X42;
				NR13_REG = 0X73;
				NR14_REG = 0X85;
				delay(2000);
				set_bkg_data(102, 18, LoopGrid);
				set_bkg_tiles(0, 0, 20, 18, LoopBKG1);
				NR10_REG = 0X00;
				NR11_REG = 0X81;
				NR12_REG = 0X42;
				NR13_REG = 0X73;
				NR14_REG = 0X85;
			}
		}
		SHOW_SPRITES;

		objective[4] = objective[5]; objective[6] = objective[7];
		while (!died && !(score != 0 && score % 16 == 0) && score != 99) {
			if (joypad() & J_UP) {
				direction = 0;
			}
			else if (joypad() & J_RIGHT) {
				direction = 1;
			}
			else if (joypad() & J_DOWN) {
				direction = 2;
			}
			else if (joypad() & J_LEFT) {
				direction = 3;
			}
			if (joypad() & J_A) {
				if (border((data[time][clone][0] - 6 * directionY(direction)), (data[time][clone][1] + 6 * directionX(direction)))) {
					time += 1;
					data[time][clone][0] = data[time - 1][clone][0] - 6 * directionY(direction);
					data[time][clone][1] = data[time - 1][clone][1] + 6 * directionX(direction);
					data[time][clone][2] = direction;
					move--;
					pointUpdate(move, 2);

					NR10_REG = 0X57;
					NR11_REG = 0X9E;
					NR12_REG = 0X43;
					NR13_REG = 0X83;
					NR14_REG = 0X86;
				}
				waitpadup();
			}
			if (joypad() & J_B) {
				time += 1;
				data[time][clone][0] = data[time - 1][clone][0];
				data[time][clone][1] = data[time - 1][clone][1];
				data[time][clone][2] = direction;
				data2[time][clone][0] = 1;
				data2[time][clone][1] = 1;
				move--;
				pointUpdate(move, 2);
				waitpadup();
			}
			for (int i = 0; i <= clone * 2 + 2; i++) {
				if (i == clone * 2) {
					set_sprite_tile(i, direction * 2);
					move_sprite(i, data[time][i / 2][0] + directionX(direction), data[time][i / 2][1] + directionY(direction));
				}
				else if (i == clone * 2 + 1) {
					set_sprite_tile(i, direction * 2 + 1);
					move_sprite(i, data[time][i / 2][0] - directionX(direction), data[time][i / 2][1] - directionY(direction));
				}
				else if (i % 2 == 0) {
					set_sprite_tile(i, data[time][i / 2][2] * 2);
					move_sprite(i, data[time][i / 2][0] + directionX(data[time][i / 2][2]), data[time][i / 2][1] + directionY(data[time][i / 2][2]));
				}
				else {
					set_sprite_tile(i, data[time][i / 2][2] * 2 + 1);
					move_sprite(i, data[time][i / 2][0] - directionX(data[time][i / 2][2]), data[time][i / 2][1] - directionY(data[time][i / 2][2]));
				}
			}
			for (int i = 0; i <= clone * 2 + 2; i++) { // could be optimized but don't wanna
				if (data2[time][i / 2][1] == 1 && i % 2 == 1) {
					data2[time][i / 2][1] = 0;
					set_sprite_tile(34, 16);
					move_sprite(34, data[time][i / 2][0], data[time][i / 2][1]);
					NR10_REG = 0X6E;
					NR11_REG = 0XB1;
					NR12_REG = 0XA4;
					NR13_REG = 0XF0;
					NR14_REG = 0X86;
					bulletShoot(data[time][i / 2][0], data[time][i / 2][1], data[time][i / 2][2]);
					move_sprite(34, 0, 0);
					if (startTime != time + 1) {
						if (targetCheck(objective, data[time][i / 2])) {
							objective[6]--;
							if (objective[6] != 0) {
								do {
									objective[2] = (((UINT8)rand()) % (UINT8)5) * 24 + 28;
									objective[3] = (((UINT8)rand()) % (UINT8)5) * 24 + 36;
									set_sprite_tile(33, 14);
									move_sprite(33, objective[2], objective[3]);
								} while ((objective[2] == objective[0] && objective[3] == objective[1]));
							}
						}
						if (shootCheck(data[time], clone, data[time][i / 2]) && !died) {
							died = true;
						}
					}
				}
			}
			if (startTime != time + 1) {
				if (crashCheck(data[time], clone)) {
					died = true;
				}
			}
			if (move == 0) {
				diedAnimation(clone, direction);
				died = true;
			}
			if (died) {
				HIDE_SPRITES;
				set_bkg_tiles(0, 0, 20, 18, LoopBKG3);
				NR10_REG = 0xEF;
				NR11_REG = 0x9D;
				NR12_REG = 0xC5;
				NR13_REG = 0x82;
				NR14_REG = 0x87;
			}
			else if (goalCheck(data[time][clone], objective)) {
				if (objective[4] != 0) {
					objective[4]--;
					if (objective[0] == 76 && objective[1] == 36) {
						move_sprite(35, 76, 132); objective[0] = 76; objective[1] = 132;
					}
					else if (objective[0] == 124 && objective[1] == 84) {
						move_sprite(35, 28, 84); objective[0] = 28; objective[1] = 84;
					}
					else if (objective[0] == 76 && objective[1] == 132) {
						move_sprite(35, 76, 36); objective[0] = 76; objective[1] = 36;
					}
					else {
						move_sprite(35, 124, 84); objective[0] = 124; objective[1] = 84;
					}
				}
				else {
					objective[4] = objective[5]; objective[6] = objective[7];
					clone++;
					score ++;
					pointUpdate(score, 0);
					delaySpeed = 0;
					while (time != 0) {
						spriteUpdate(time, clone, data, data2, true);
						for (int j = 0; j < clone; j++) {
							if (data2[time][j][0] == 1) {
								data2[time][j][1] = 1;
							}
						}
						time--;
						move = 40 - time;
						pointUpdate(move, 2);
						delay(200 - delaySpeed);
						delaySpeed += 5;
					}
					delay(200);
					if (score % 16 != 0 && score != 99) {
						while (time != startTime) {
							spriteUpdate(time, clone, data, data2, false);
							time++;
							move = 40 - time;
							pointUpdate(move, 2);
							delay(200 - delaySpeed);
							delaySpeed -= 5;
						}
					}
					time = startTime;
					startTime++;
					move = 40 - startTime;
					switch (clone % 4) {
					case 0: data[time][clone][0] = 76; data[time][clone][1] = 132; move_sprite(35, 76, 36); objective[0] = 76; objective[1] = 36; break;
					case 1: data[time][clone][0] = 28; data[time][clone][1] = 84; move_sprite(35, 124, 84); objective[0] = 124; objective[1] = 84; break;
					case 2: data[time][clone][0] = 76; data[time][clone][1] = 36; move_sprite(35, 76, 132); objective[0] = 76; objective[1] = 132; break;
					case 3: data[time][clone][0] = 124; data[time][clone][1] = 84; move_sprite(35, 28, 84); objective[0] = 28; objective[1] = 84; break;
					default: data[time][clone][0] = 76; data[time][clone][1] = 132; move_sprite(35, 76, 36); objective[0] = 76; objective[1] = 36;
					}
					if (objective[7] != 0) {
						do {
							objective[2] = (((UINT8)rand()) % (UINT8)5) * 24 + 28;
							objective[3] = (((UINT8)rand()) % (UINT8)5) * 24 + 36;
							set_sprite_tile(33, 14);
							move_sprite(33, objective[2], objective[3]);
						} while ((objective[2] == objective[0] && objective[3] == objective[1]));
					}
					direction = clone % 4;
					data[time][clone][2] = direction;
				}
			}
			delay(1);
		}
		delay(1);
		if (score % 16 == 0 && score != 0) {
			HIDE_SPRITES;
			score++;
			for (int i = 0; i < 34; i++) {
				move_sprite(i, 0, 0);
			}
		}
		else {
			if (score == 99) {
				HIDE_SPRITES;
				set_bkg_tiles(0, 0, 20, 18, LoopBKGEnd);
			}
			move = 40;
			while (joypad() != J_START) {

			}
			for (int i = 0; i < 34; i++) {
				move_sprite(i, 0, 0);
			}
		}
	}
	
}